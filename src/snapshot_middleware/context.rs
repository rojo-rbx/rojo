use std::{fmt, ops::Deref, path::PathBuf};

use rlua::{Lua, RegistryKey};

#[derive(Debug)]
pub struct InstanceSnapshotContext {
    /// Holds all the state needed to run user plugins as part of the snapshot
    /// process.
    ///
    /// If this is None, then plugins should not be evaluated at all.
    pub plugin_context: Option<SnapshotPluginContext>,
}

impl Default for InstanceSnapshotContext {
    fn default() -> Self {
        Self {
            plugin_context: None,
        }
    }
}

#[derive(Debug)]
pub struct SnapshotPluginContext {
    pub state: IgnoreDebug<Lua>,

    /// Paths to the user plugins files. These paths are generated by the root
    /// project file, if there is one.
    pub plugin_paths: Vec<PathBuf>,

    /// Lazy-initialized registry keys pointing to the values returned by each
    /// user plugin. When processing user plugins, these should be applied in
    /// order.
    pub plugin_functions: Option<Vec<RegistryKey>>,
}

impl SnapshotPluginContext {
    pub fn new(plugin_paths: Vec<PathBuf>) -> Self {
        Self {
            state: IgnoreDebug(Lua::new()),
            plugin_paths,
            plugin_functions: None,
        }
    }
}

/// Utility type to enable having a field of a struct not implement Debug and
/// instead show a placeholder.
#[derive(Clone)]
pub struct IgnoreDebug<T>(pub T);

impl<T> fmt::Debug for IgnoreDebug<T> {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        write!(formatter, "<no debug representation>")
    }
}

impl<T> Deref for IgnoreDebug<T> {
    type Target = T;

    fn deref(&self) -> &T {
        &self.0
    }
}

pub struct ImfsSnapshotContext;
